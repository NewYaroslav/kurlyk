/*!
\mainpage Kurlyk Library

\section intro_sec Introduction

Kurlyk is a header-only C++ library that currently wraps **libcurl** and
**Simple-WebSocket-Server** to provide convenient HTTP and WebSocket clients.
Its core is backend-agnostic, so alternative implementations can be plugged in
if neededâ€”planned support includes an Emscripten backend. The library hides
much of the networking boilerplate and offers an easy way to issue asynchronous
requests, process WebSocket events and apply rate limiting.

\section features_sec Features

- HTTP and WebSocket clients with a common, class-based API.
- Asynchronous or synchronous execution via a background worker.
- Rate limiting for both HTTP requests and WebSocket messages.
- Automatic reconnection logic for WebSocket connections.
- Proxy support, configurable timeouts and custom headers.
- Header-only design, works with C++11 and newer.

\section usage_sec Usage

\code{.cpp}
#include <kurlyk.hpp>
#include <iostream>
#include <thread>

int main() {
    kurlyk::init(true); // start worker thread

    kurlyk::HttpClient http("https://httpbin.org");
    http.get("/ip", {}, {}, [](kurlyk::HttpResponsePtr res) {
        std::cout << "Status: " << res->status_code << "\n" << res->content << std::endl;
    });

    kurlyk::WebSocketClient ws("wss://echo-websocket.fly.dev/");
    ws.on_event([](std::unique_ptr<kurlyk::WebSocketEventData> e) {
        if (e->event_type == kurlyk::WebSocketEventType::WS_MESSAGE)
            std::cout << "Message: " << e->message << std::endl;
    });
    ws.connect_and_wait();
    ws.send_message("Hello!");
    std::this_thread::sleep_for(std::chrono::seconds(1));
    ws.disconnect_and_wait();

    kurlyk::deinit();
}
\endcode

\section error_sec Error Handling

The library centralizes exception reporting through the
`core::NetworkWorker`. Applications may register callbacks with
`kurlyk::add_error_handler` to intercept errors raised inside Kurlyk and
forward them to a logging system or metrics collector.

Handlers use the `kurlyk::core::NetworkWorker::ErrorHandler` signature:

\code{.cpp}
using ErrorHandler = std::function<
    void(const std::exception&,
         const char* msg,
         const char* file,
         int line,
         const char* func)>;
\endcode

Whenever an internal operation encounters an exception and invokes
`KURLYK_HANDLE_ERROR`, all registered handlers receive the exception, an
optional message, source file, line and function. This allows detailed
logging of issues without terminating the program.

\code{.cpp}
kurlyk::add_error_handler([](const std::exception& ex,
                             const char* msg,
                             const char* file,
                             int line,
                             const char* func) {
    std::cerr << "Kurlyk error: " << msg
              << " (" << ex.what() << ") at "
              << file << ':' << line
              << " in " << func << std::endl;
});
\endcode

\section install_sec Installation

Add the `include` directory to your compiler search path and include
`<kurlyk.hpp>` in your sources.  The repository contains third party
dependencies used by the examples, but for your own project you need
`libcurl`, `OpenSSL` and either Boost.Asio or standalone Asio together
with **Simple-WebSocket-Server**.  Kurlyk itself is header-only and works
with C++11 or later.

\subsection config_sec Configuration Macros
Several macros can be defined before including the library to tailor the
build:
- `KURLYK_HTTP_SUPPORT` and `KURLYK_WEBSOCKET_SUPPORT` toggle the HTTP or
  WebSocket parts of the library.
- `KURLYK_AUTO_INIT` controls automatic manager registration during static
  initialization, while `KURLYK_AUTO_INIT_USE_ASYNC` runs the worker thread
  in the background when auto init is enabled.

\section repo_sec Repository

[Kurlyk Library GitHub repository](https://github.com/NewYaroslav/kurlyk).

\section license_sec License

This library is licensed under the MIT License. See the LICENSE file for more details.
*/

